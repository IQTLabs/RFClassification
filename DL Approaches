{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "8d4e062b",
   "metadata": {},
   "source": [
    "## Deep Learning Approaches for RF-based detection & classification"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "7df87784",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.image as mpimg\n",
    "import random\n",
    "\n",
    "# import the torch packages\n",
    "from torch.nn import Module\n",
    "from torch.nn import Conv2d\n",
    "from torch.nn import Linear\n",
    "from torch.nn import MaxPool2d\n",
    "from torch.nn import ReLU\n",
    "from torch.nn import LogSoftmax\n",
    "from torch import flatten\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "from torch.utils.data import Dataset\n",
    "\n",
    "import torchvision.models as models\n",
    "\n",
    "from sklearn import preprocessing\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "from sklearn.neighbors import KNeighborsClassifier\n",
    "from sklearn.model_selection import KFold\n",
    "from sklearn.model_selection import GridSearchCV\n",
    "from sklearn.metrics import accuracy_score\n",
    "from sklearn.metrics import f1_score\n",
    "from sklearn import svm\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.pipeline import Pipeline\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "# import custom functions\n",
    "from helper_functions import *\n",
    "from latency_helpers import *\n",
    "from loading_functions import *\n",
    "\n",
    "from Torch_Models import *\n",
    "from file_paths import *\n",
    "from models import *\n",
    "\n",
    "# from torchsummary import summary"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13a4835a",
   "metadata": {},
   "source": [
    "### Load DroneDetect Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "88743ba5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loading DroneRF Dataset\n",
      "/home/kzhou/main/Features_DroneRF/IMG_PSD_H_1024_20/\n",
      "dataset size 2712\n",
      "shape of each item torch.Size([224, 224, 3])\n"
     ]
    }
   ],
   "source": [
    "feat_name = 'PSD'\n",
    "t_seg = 20 #ms\n",
    "n_per_seg = 1024\n",
    "interferences = ['WIFI', 'BLUE', 'BOTH', 'CLEAN']\n",
    "output_name = 'drones'\n",
    "feat_format = 'IMG'\n",
    "which_dataset = 'dronerf'\n",
    "\n",
    "if which_dataset == 'dronerf':\n",
    "    print('Loading DroneRF Dataset')\n",
    "    highlow = 'H'\n",
    "    dataset = DroneRFTorch(dronerf_feat_path, feat_name, t_seg, n_per_seg,\n",
    "                       feat_format, output_name, highlow)\n",
    "elif which_dataset == 'dronedetect':\n",
    "    print('Loading DroneDetect Dataset')\n",
    "    dataset = DroneDetectTorch(dronedetect_feat_path, feat_name, t_seg, n_per_seg, feat_format,\n",
    "                                    output_name, interferences)\n",
    "X_use, y_use = dataset.get_arrays()\n",
    "\n",
    "# Set fixed number of samples\n",
    "n_samps = 1000\n",
    "i_test= random.sample(range(len(dataset)), n_samps)\n",
    "\n",
    "X_use, y_use = dataset.__getitem__(i_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "c4bf51c6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "d = dataset.__getitem__(4)[0]\n",
    "plt.imshow(d)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57c5339d",
   "metadata": {},
   "source": [
    "### Load gamutRF Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "2be57236",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'GamutRFDataset' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Input \u001b[0;32mIn [1]\u001b[0m, in \u001b[0;36m<cell line: 17>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     14\u001b[0m save_iter \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m200\u001b[39m\n\u001b[1;32m     15\u001b[0m eval_iter \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m10000\u001b[39m\n\u001b[0;32m---> 17\u001b[0m dataset \u001b[38;5;241m=\u001b[39m \u001b[43mGamutRFDataset\u001b[49m(label_dirs, sample_secs\u001b[38;5;241m=\u001b[39msample_secs, nfft\u001b[38;5;241m=\u001b[39mnfft)\n",
      "\u001b[0;31mNameError\u001b[0m: name 'GamutRFDataset' is not defined"
     ]
    }
   ],
   "source": [
    "label_dirs= {\n",
    "    'drone': ['data/gamutrf-birdseye-field-days/leesburg_field_day_2022_06_15/worker1/','data/gamutrf-birdseye-field-days/pdx_field_day_2022_05_26/worker1/gamutrf/'], \n",
    "    'wifi_2_4': ['data/gamutrf-pdx/07_21_2022/wifi_2_4/'], \n",
    "    'wifi_5': ['data/gamutrf-pdx/07_21_2022/wifi_5/']\n",
    "}\n",
    "\n",
    "\n",
    "sample_secs = 0.02\n",
    "nfft = 512\n",
    "batch_size = 8\n",
    "num_workers = 19\n",
    "num_epochs = 4\n",
    "train_val_test_split = [0.75, 0.05, 0.20]\n",
    "save_iter = 200\n",
    "eval_iter = 10000\n",
    "\n",
    "dataset = GamutRFDataset(label_dirs, sample_secs=sample_secs, nfft=nfft)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "31ad3ec6",
   "metadata": {},
   "source": [
    "## VGG16 Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "3fd24d89",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "vgg16 = models.vgg16(pretrained=True)\n",
    "# summary(vgg16, (3,224,224))\n",
    "\n",
    "modules=list(vgg16.children())[:-1]\n",
    "vggmodel=nn.Sequential(*modules)\n",
    "\n",
    "for p in vggmodel.parameters():\n",
    "    p.requires_grad = False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "81a79389",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([1, 3, 224, 224])\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "tensor([0., 0., 0.,  ..., 0., 0., 0.])"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# test one input\n",
    "d = dataset.__getitem__(11)\n",
    "inarr = d[0]\n",
    "inarr = torch.moveaxis(inarr, 2, 0)\n",
    "inarr =inarr.unsqueeze(dim=0)\n",
    "print(inarr.shape)\n",
    "# print(inarr.shape)\n",
    "# postmove = inarr[0]\n",
    "# print(premove==postmove) # confirm it is the same channel\n",
    "\n",
    "# WHEN using single channel array format\n",
    "# inputr = inarr.repeat(1,3,1,1)\n",
    "# inputr = inputr.to(device)\n",
    "out = vggmodel(inarr)\n",
    "\n",
    "# reshape the output\n",
    "out.flatten()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3e445e2e",
   "metadata": {},
   "source": [
    "## Resnet Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "47b6d844",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Transfer learning from Resnet50 & Apply Logistic Regression (Swinney paper)\n",
    "\n",
    "# use pretrained resnet feature and just keep up to the last layer\n",
    "resnet50 = models.resnet50(pretrained=True)\n",
    "modules=list(resnet50.children())[:-2]\n",
    "resnet50=nn.Sequential(*modules)\n",
    "for p in resnet50.parameters():\n",
    "    p.requires_grad = False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "440b23cd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "torch.Size([1, 3, 224, 224])\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "torch.Size([1, 2048, 7, 7])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# test resnet\n",
    "# input = torch.randn(1,1,30,300)\n",
    "d = dataset.__getitem__(0)\n",
    "inarr = d[0]\n",
    "\n",
    "inarr = torch.moveaxis(inarr, 2, 0)\n",
    "inarr = inarr.unsqueeze(dim=0)\n",
    "print(inarr.shape)\n",
    "# resnet50(inarr).shape\n",
    "\n",
    "resnet50(inarr).shape"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8bce13e9",
   "metadata": {},
   "source": [
    "### Generate Pretrained/Transfer Learning Features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "85a4b583",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████████████████████████████████████████| 36778/36778 [03:56<00:00, 155.59it/s]\n"
     ]
    }
   ],
   "source": [
    "ModelDict = {'vgg':vggmodel, 'resnet': resnet50}\n",
    "\n",
    "which_model = 'resnet'\n",
    "\n",
    "device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n",
    "ModelDict[which_model] = ModelDict[which_model].to(device) #set model to device\n",
    "\n",
    "Feats = []\n",
    "y_num = [] # numerical values for y\n",
    "for n in tqdm(range(len(dataset))):\n",
    "    d = dataset.__getitem__(n)\n",
    "    inarr = d[0]\n",
    "#     inputr = inarr.repeat(1,3,1,1)  # repeat to have 3 channels of the same info\n",
    "    inputr = torch.moveaxis(inarr, 2, 0) # move axis to have channels come first\n",
    "    inputr =inputr.unsqueeze(dim=0)\n",
    "    inputr = inputr.to(device)\n",
    "    out = ModelDict[which_model](inputr)\n",
    "    \n",
    "    Feats.append(out.cpu().numpy().flatten())\n",
    "    y_num.append(np.array(d[1]))\n",
    "\n",
    "Feats = np.array(Feats)\n",
    "y_num = np.array(y_num)\n",
    "\n",
    "# flatten the middle dimension\n",
    "Feats = Feats.reshape(Feats.shape[0], Feats.shape[-1])\n",
    "# invert labels back to categorical\n",
    "# vgg_y_cat = dataset.le.inverse_transform(vgg_y.astype(np.int64))\n",
    "y_cat = np.array([dataset.idx_to_class[i] for i in y_num])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "4da21074",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Save VGG features\n",
    "# vgg_save = {'feats': vgg_feats, 'y_cat':vgg_y_cat, 'y':vgg_y}\n",
    "# file_name = 'transfer_learning_feats/VggFeats_'+str(seg_len)+'_'+str(n_per_seg)+'correct_psd_img'\n",
    "# np.save(file_name, vgg_save)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4be6ec2",
   "metadata": {},
   "source": [
    "### Run Classifier"]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "9b769a4d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Shape of Input Features: (n sample x n feats): (36778, 100352)\n"
     ]
    }
   ],
   "source": [
    "Xs_feat = Feats # which features to use for logit reg\n",
    "y_cat = y_cat\n",
    "print('Shape of Input Features: (n sample x n feats):', Xs_feat.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "f07bbecd",
   "metadata": {},
   "outputs": [],
   "source": [
    "## KFOLD split\n",
    "\n",
    "k_fold = 5\n",
    "cv = KFold(n_splits=k_fold, random_state=1, shuffle=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7aab9544",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "0it [00:00, ?it/s]/home/kzhou/.pyenv/versions/3.8.2/envs/main/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "1it [04:47, 287.64s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.719,\t F1: 0.719\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/kzhou/.pyenv/versions/3.8.2/envs/main/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "2it [09:19, 278.16s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.732,\t F1: 0.733\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/kzhou/.pyenv/versions/3.8.2/envs/main/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "3it [13:46, 273.11s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.725,\t F1: 0.725\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/kzhou/.pyenv/versions/3.8.2/envs/main/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "4it [18:15, 271.40s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.722,\t F1: 0.722\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/home/kzhou/.pyenv/versions/3.8.2/envs/main/lib/python3.8/site-packages/sklearn/linear_model/_logistic.py:444: ConvergenceWarning: lbfgs failed to converge (status=1):\n",
      "STOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n",
      "\n",
      "Increase the number of iterations (max_iter) or scale the data as shown in:\n",
      "    https://scikit-learn.org/stable/modules/preprocessing.html\n",
      "Please also refer to the documentation for alternative solver options:\n",
      "    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n",
      "  n_iter_i = _check_optimize_result(\n",
      "5it [22:43, 272.64s/it]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.723,\t F1: 0.723\n",
      "Net+LR: average test acc: 0.724, F1: 0.724, Run-time: 0.814ms\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "# Apply PCA with LR and kNN\n",
    "sc_ls = []\n",
    "f1_ls = []\n",
    "tm_ls = []\n",
    "which_clf = 'lr'\n",
    "for train_ix, test_ix in tqdm(cv.split(Xs_feat)):\n",
    "    scaler = StandardScaler()\n",
    "    Xtrainscale = scaler.fit_transform(Xs_feat[train_ix])\n",
    "    \n",
    "    pca = PCA(n_components=1000) # was using n_comp=10000\n",
    "    pca.fit(Xs_feat[train_ix])\n",
    "    Xtrainpca = pca.transform(Xtrainscale)\n",
    "    \n",
    "    if which_clf == 'lr':\n",
    "        clf = LogisticRegression(max_iter=1000) # was using max_iter=10000\n",
    "    else:\n",
    "        clf = KNeighborsClassifier(n_neighbors=5)\n",
    "    \n",
    "    clf.fit(Xtrainpca, y_cat[train_ix])\n",
    "    \n",
    "    # test\n",
    "    start = time.time()\n",
    "    Xtestscale = scaler.transform(Xs_feat[test_ix])\n",
    "    Xtestpca = pca.transform(Xtestscale)\n",
    "    y_pred = clf.predict(Xtestpca)\n",
    "    end = time.time()\n",
    "    \n",
    "    t_ave = (end-start)/Xtestpca.shape[0] # batch measure time\n",
    "    tm_ls.append(t_ave)\n",
    "    \n",
    "    sc = accuracy_score(y_cat[test_ix], y_pred)\n",
    "    sc_ls.append(sc)\n",
    "    f1 = f1_score(y_cat[test_ix], y_pred, average='weighted')\n",
    "    f1_ls.append(f1)\n",
    "    print('Accuracy: {:.3},\\t F1: {:.3}'.format(sc,f1))\n",
    "\n",
    "out_msg = 'Net+LR: average test acc: {:.3}, F1: {:.3}, Run-time: {:.3}ms'.format(np.mean(sc_ls), np.mean(f1_ls), np.mean(tm_ls)*1e3)\n",
    "print(out_msg)  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "75156f88",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[0.0005148707321816803,\n",
       " 0.0005234912641847237,\n",
       " 0.0005121750670130158,\n",
       " 0.0005138173020750074,\n",
       " 0.0005133497936745498]"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tm_ls"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "d3eea904",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Directly apply LR - too many features too long\n",
    "\n",
    "# model parameters\n",
    "# Cs=list(map(lambda x:pow(10,x),range(-2,2,1)))\n",
    "# print('Cs:', Cs)\n",
    "\n",
    "# best_params_ls = []\n",
    "# acc_ls = []\n",
    "# f1_ls = []\n",
    "# runt_ls = []\n",
    "\n",
    "# parameters = {'C':Cs}\n",
    "\n",
    "# for train_ix, test_ix in tqdm(cv.split(Xs_feat)):\n",
    "    \n",
    "#     # find the optimal hypber parameters\n",
    "#     lr = LogisticRegression(solver='saga')\n",
    "# #     clf = GridSearchCV(lr, parameters, n_jobs=1) # gridsearch cv\n",
    "#     clf = LogisticRegression(C =1.0, max_iter=5000, class_weight = 'balanced',n_jobs=1) # fixed parameter\n",
    "    \n",
    "#     scaler = preprocessing.StandardScaler().fit(Xs_feat[train_ix])\n",
    "#     X_train_scale = scaler.transform(Xs_feat[train_ix])\n",
    "    \n",
    "#     clf.fit(X_train_scale, y_cat[train_ix])\n",
    "    \n",
    "# #     print(clf.best_params_)\n",
    "# #     best_params_ls.append(clf.best_params_)\n",
    "    \n",
    "#     # predict on the test data\n",
    "#     X_test_scale = scaler.transform(Xs_feat[test_ix])\n",
    "#     y_pred, runtimes = atomic_benchmark_estimator(clf, X_test_scale, output_type= '<U3', \n",
    "#                                                   verbose=False)\n",
    "#     runt_ls.append(np.mean(runtimes))\n",
    "    \n",
    "#     acc = accuracy_score(y_cat[test_ix], y_pred)\n",
    "#     f1 = f1_score(y_cat[test_ix], y_pred, average='weighted')\n",
    "#     print('Accuracy: {:.3},\\t F1: {:.3}'.format(acc,f1))\n",
    "#     acc_ls.append(acc)\n",
    "#     f1_ls.append(f1)\n",
    "    \n",
    "# out_msg = 'Net+LR: average test acc: {:.2}, F1: {:.2}, Run-time: {:.2}ms'.format(np.mean(acc_ls), np.mean(f1_ls), np.mean(runt_ls)*1e3)\n",
    "# print(out_msg)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "8ce4b401",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# neigh = KNeighborsClassifier(n_neighbors=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fbfedc04",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "list of neighbours: [100]\n"
     ]
    }
   ],
   "source": [
    "## Fixed parameter kNN (LONG run time - too many features)\n",
    "# k_fold = 5\n",
    "# cv = KFold(n_splits=k_fold, random_state=10, shuffle=True)\n",
    "\n",
    "# # Ns=list(range(2,100,20))\n",
    "# # Ns = [100]\n",
    "# parameters = {'n_neighbors':Ns}\n",
    "# print('list of neighbours:', Ns)\n",
    "\n",
    "# Xs_arr = Vgg_Feats\n",
    "# y_arr = Vgg_y_cat\n",
    "\n",
    "# best_params_ls = []\n",
    "# score_ls = []\n",
    "# f1_ls = []\n",
    "\n",
    "# for train_ix, test_ix in cv.split(Xs_arr):\n",
    "#     # scale data\n",
    "#     scaler = preprocessing.StandardScaler().fit(Xs_arr[train_ix])\n",
    "#     X_train_scale = scaler.transform(Xs_arr[train_ix])\n",
    "    \n",
    "#     # find the optimal hypber parameters\n",
    "#     clf = KNeighborsClassifier(n_neighbors=5)\n",
    "# #     clf = GridSearchCV(neigh, parameters, n_jobs=1)\n",
    "#     clf.fit(X_train_scale, y_arr[train_ix])\n",
    "# #     print(clf.best_parameters)\n",
    "    \n",
    "#     # predict on the test data\n",
    "#     X_test_scale = scaler.transform(Xs_arr[test_ix])\n",
    "# #     y_pred = clf.predict(X_test_scale)\n",
    "#     y_pred, runtimes = atomic_benchmark_estimator(clf, X_test_scale, output_type= '<U3', \n",
    "#                                                   verbose=False)\n",
    "#     acc = accuracy_score(y_arr[test_ix], y_pred)\n",
    "#     f1 = f1_score(y_arr[test_ix], y_pred, average='weighted')\n",
    "#     f1_ls.append(f1)\n",
    "#     print('Accuracy: {:.3},\\t F1: {:.3}'.format(acc,f1))\n",
    "#     score_ls.append(acc)\n",
    "    \n",
    "# print('VGG feats+kNN K-fold average test score:', np.mean(score_ls))\n",
    "# print('VGG feats+kNN K-fold average test F1:', np.mean(f1_ls))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "80076188",
   "metadata": {},
   "source": [
    "## Fully Connected Layer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3b356583",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import Torch models\n",
    "from Torch_Models import *"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "057fdafd",
   "metadata": {},
   "source": [
    "### Kfold CV"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "8c1f7ab1",
   "metadata": {},
   "outputs": [],
   "source": [
    "from nn_functions import runkfoldcv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "f67796ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Configuration options\n",
    "k_folds = 5\n",
    "\n",
    "batch_size = 128 # 128\n",
    "num_classes = 7\n",
    "learning_rate = 0.01\n",
    "num_epochs = 10 # 0\n",
    "momentum = 0.95\n",
    "l2reg = 1e-4\n",
    "\n",
    "Model = VGGFC(num_classes)\n",
    "device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "ece73702",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "--------------------------------\n",
      "FOLD 0\n",
      "--------------------------------\n",
      "Starting epoch 1\n",
      "    Loss after mini-batch    50: 0.21611\n",
      "    Loss after mini-batch   100: 0.23081\n",
      "    Loss after mini-batch   150: 0.22870\n",
      "    Loss after mini-batch   200: 0.23318\n",
      "Starting epoch 2\n",
      "    Loss after mini-batch    50: 0.22025\n",
      "    Loss after mini-batch   100: 0.21542\n",
      "    Loss after mini-batch   150: 0.22238\n",
      "    Loss after mini-batch   200: 0.22282\n",
      "Starting epoch 3\n",
      "    Loss after mini-batch    50: 0.21271\n",
      "    Loss after mini-batch   100: 0.21916\n",
      "    Loss after mini-batch   150: 0.21282\n",
      "    Loss after mini-batch   200: 0.21872\n",
      "Starting epoch 4\n",
      "    Loss after mini-batch    50: 0.20875\n",
      "    Loss after mini-batch   100: 0.21702\n",
      "    Loss after mini-batch   150: 0.21105\n",
      "    Loss after mini-batch   200: 0.20857\n",
      "Starting epoch 5\n",
      "    Loss after mini-batch    50: 0.20477\n",
      "    Loss after mini-batch   100: 0.20615\n",
      "    Loss after mini-batch   150: 0.21356\n",
      "    Loss after mini-batch   200: 0.20486\n",
      "Starting epoch 6\n",
      "    Loss after mini-batch    50: 0.20678\n",
      "    Loss after mini-batch   100: 0.20490\n",
      "    Loss after mini-batch   150: 0.20323\n",
      "    Loss after mini-batch   200: 0.20357\n",
      "Starting epoch 7\n",
      "    Loss after mini-batch    50: 0.20139\n",
      "    Loss after mini-batch   100: 0.20259\n",
      "    Loss after mini-batch   150: 0.20221\n",
      "    Loss after mini-batch   200: 0.21059\n",
      "Starting epoch 8\n",
      "    Loss after mini-batch    50: 0.19075\n",
      "    Loss after mini-batch   100: 0.20089\n",
      "    Loss after mini-batch   150: 0.20219\n",
      "    Loss after mini-batch   200: 0.20622\n",
      "Starting epoch 9\n",
      "    Loss after mini-batch    50: 0.20032\n",
      "    Loss after mini-batch   100: 0.19470\n",
      "    Loss after mini-batch   150: 0.19704\n",
      "    Loss after mini-batch   200: 0.19810\n",
      "Starting epoch 10\n",
      "    Loss after mini-batch    50: 0.19359\n",
      "    Loss after mini-batch   100: 0.19233\n",
      "    Loss after mini-batch   150: 0.19559\n",
      "    Loss after mini-batch   200: 0.19293\n",
      "Starting testing\n",
      "----------------\n",
      "Accuracy for fold 0: 91.64 %\n",
      "F1 for fold 0: 0.92 \n",
      "Runtime for fold 0: 0.0057 s\n",
      "--------------------------------\n",
      "FOLD 1\n",
      "--------------------------------\n",
      "Starting epoch 1\n",
      "    Loss after mini-batch    50: 0.20640\n",
      "    Loss after mini-batch   100: 0.20344\n",
      "    Loss after mini-batch   150: 0.20764\n",
      "    Loss after mini-batch   200: 0.20371\n",
      "Starting epoch 2\n",
      "    Loss after mini-batch    50: 0.19874\n",
      "    Loss after mini-batch   100: 0.19279\n",
      "    Loss after mini-batch   150: 0.20458\n",
      "    Loss after mini-batch   200: 0.19378\n",
      "Starting epoch 3\n",
      "    Loss after mini-batch    50: 0.19644\n",
      "    Loss after mini-batch   100: 0.20087\n",
      "    Loss after mini-batch   150: 0.19580\n",
      "    Loss after mini-batch   200: 0.19586\n",
      "Starting epoch 4\n",
      "    Loss after mini-batch    50: 0.18543\n",
      "    Loss after mini-batch   100: 0.19630\n",
      "    Loss after mini-batch   150: 0.19607\n",
      "    Loss after mini-batch   200: 0.19530\n",
      "Starting epoch 5\n",
      "    Loss after mini-batch    50: 0.18489\n",
      "    Loss after mini-batch   100: 0.19480\n",
      "    Loss after mini-batch   150: 0.19048\n",
      "    Loss after mini-batch   200: 0.18585\n",
      "Starting epoch 6\n",
      "    Loss after mini-batch    50: 0.18172\n",
      "    Loss after mini-batch   100: 0.18546\n",
      "    Loss after mini-batch   150: 0.19167\n",
      "    Loss after mini-batch   200: 0.18302\n",
      "Starting epoch 7\n",
      "    Loss after mini-batch    50: 0.18040\n",
      "    Loss after mini-batch   100: 0.18397\n",
      "    Loss after mini-batch   150: 0.17943\n",
      "    Loss after mini-batch   200: 0.19092\n",
      "Starting epoch 8\n",
      "    Loss after mini-batch    50: 0.18657\n",
      "    Loss after mini-batch   100: 0.18231\n",
      "    Loss after mini-batch   150: 0.17525\n",
      "    Loss after mini-batch   200: 0.18513\n",
      "Starting epoch 9\n",
      "    Loss after mini-batch    50: 0.18527\n",
      "    Loss after mini-batch   100: 0.17363\n",
      "    Loss after mini-batch   150: 0.17686\n",
      "    Loss after mini-batch   200: 0.18654\n",
      "Starting epoch 10\n",
      "    Loss after mini-batch    50: 0.17766\n",
      "    Loss after mini-batch   100: 0.17687\n",
      "    Loss after mini-batch   150: 0.18324\n",
      "    Loss after mini-batch   200: 0.17613\n",
      "Starting testing\n",
      "----------------\n",
      "Accuracy for fold 1: 92.87 %\n",
      "F1 for fold 1: 0.93 \n",
      "Runtime for fold 1: 0.0057 s\n",
      "--------------------------------\n",
      "FOLD 2\n",
      "--------------------------------\n",
      "Starting epoch 1\n",
      "    Loss after mini-batch    50: 0.18953\n",
      "    Loss after mini-batch   100: 0.18278\n",
      "    Loss after mini-batch   150: 0.19074\n",
      "    Loss after mini-batch   200: 0.18323\n",
      "Starting epoch 2\n",
      "    Loss after mini-batch    50: 0.18251\n",
      "    Loss after mini-batch   100: 0.17989\n",
      "    Loss after mini-batch   150: 0.18577\n",
      "    Loss after mini-batch   200: 0.18109\n",
      "Starting epoch 3\n",
      "    Loss after mini-batch    50: 0.17309\n",
      "    Loss after mini-batch   100: 0.18050\n",
      "    Loss after mini-batch   150: 0.18379\n",
      "    Loss after mini-batch   200: 0.17434\n",
      "Starting epoch 4\n",
      "    Loss after mini-batch    50: 0.17085\n",
      "    Loss after mini-batch   100: 0.17058\n",
      "    Loss after mini-batch   150: 0.18564\n",
      "    Loss after mini-batch   200: 0.17604\n",
      "Starting epoch 5\n",
      "    Loss after mini-batch    50: 0.16926\n",
      "    Loss after mini-batch   100: 0.17229\n",
      "    Loss after mini-batch   150: 0.17867\n",
      "    Loss after mini-batch   200: 0.16974\n",
      "Starting epoch 6\n",
      "    Loss after mini-batch    50: 0.16943\n",
      "    Loss after mini-batch   100: 0.17833\n",
      "    Loss after mini-batch   150: 0.17062\n",
      "    Loss after mini-batch   200: 0.17068\n",
      "Starting epoch 7\n",
      "    Loss after mini-batch    50: 0.16834\n",
      "    Loss after mini-batch   100: 0.16996\n",
      "    Loss after mini-batch   150: 0.16754\n",
      "    Loss after mini-batch   200: 0.17007\n",
      "Starting epoch 8\n",
      "    Loss after mini-batch    50: 0.16992\n",
      "    Loss after mini-batch   100: 0.15968\n",
      "    Loss after mini-batch   150: 0.16076\n",
      "    Loss after mini-batch   200: 0.16875\n",
      "Starting epoch 9\n",
      "    Loss after mini-batch    50: 0.15917\n",
      "    Loss after mini-batch   100: 0.16284\n",
      "    Loss after mini-batch   150: 0.16923\n",
      "    Loss after mini-batch   200: 0.16468\n",
      "Starting epoch 10\n",
      "    Loss after mini-batch    50: 0.16372\n",
      "    Loss after mini-batch   100: 0.16020\n",
      "    Loss after mini-batch   150: 0.15630\n",
      "    Loss after mini-batch   200: 0.16888\n",
      "Starting testing\n",
      "----------------\n",
      "Accuracy for fold 2: 94.09 %\n",
      "F1 for fold 2: 0.94 \n",
      "Runtime for fold 2: 0.0057 s\n",
      "--------------------------------\n",
      "FOLD 3\n",
      "--------------------------------\n",
      "Starting epoch 1\n",
      "    Loss after mini-batch    50: 0.17259\n",
      "    Loss after mini-batch   100: 0.16599\n",
      "    Loss after mini-batch   150: 0.17562\n",
      "    Loss after mini-batch   200: 0.16449\n",
      "Starting epoch 2\n",
      "    Loss after mini-batch    50: 0.16340\n",
      "    Loss after mini-batch   100: 0.16551\n",
      "    Loss after mini-batch   150: 0.16449\n",
      "    Loss after mini-batch   200: 0.16293\n",
      "Starting epoch 3\n",
      "    Loss after mini-batch    50: 0.15863\n",
      "    Loss after mini-batch   100: 0.16278\n",
      "    Loss after mini-batch   150: 0.16199\n",
      "    Loss after mini-batch   200: 0.16354\n",
      "Starting epoch 4\n",
      "    Loss after mini-batch    50: 0.14981\n",
      "    Loss after mini-batch   100: 0.16087\n",
      "    Loss after mini-batch   150: 0.16499\n",
      "    Loss after mini-batch   200: 0.16111\n",
      "Starting epoch 5\n",
      "    Loss after mini-batch    50: 0.15910\n",
      "    Loss after mini-batch   100: 0.15280\n",
      "    Loss after mini-batch   150: 0.15817\n",
      "    Loss after mini-batch   200: 0.15396\n",
      "Starting epoch 6\n",
      "    Loss after mini-batch    50: 0.15089\n",
      "    Loss after mini-batch   100: 0.15658\n",
      "    Loss after mini-batch   150: 0.14915\n",
      "    Loss after mini-batch   200: 0.16400\n",
      "Starting epoch 7\n",
      "    Loss after mini-batch    50: 0.14532\n",
      "    Loss after mini-batch   100: 0.15889\n",
      "    Loss after mini-batch   150: 0.15310\n",
      "    Loss after mini-batch   200: 0.15493\n",
      "Starting epoch 8\n",
      "    Loss after mini-batch    50: 0.15123\n",
      "    Loss after mini-batch   100: 0.15333\n",
      "    Loss after mini-batch   150: 0.15368\n",
      "    Loss after mini-batch   200: 0.15296\n",
      "Starting epoch 9\n",
      "    Loss after mini-batch    50: 0.15109\n",
      "    Loss after mini-batch   100: 0.14296\n",
      "    Loss after mini-batch   150: 0.15182\n",
      "    Loss after mini-batch   200: 0.14831\n",
      "Starting epoch 10\n",
      "    Loss after mini-batch    50: 0.14473\n",
      "    Loss after mini-batch   100: 0.14675\n",
      "    Loss after mini-batch   150: 0.14471\n",
      "    Loss after mini-batch   200: 0.15003\n",
      "Starting testing\n",
      "----------------\n",
      "Accuracy for fold 3: 94.61 %\n",
      "F1 for fold 3: 0.95 \n",
      "Runtime for fold 3: 0.0057 s\n",
      "--------------------------------\n",
      "FOLD 4\n",
      "--------------------------------\n",
      "Starting epoch 1\n",
      "    Loss after mini-batch    50: 0.15476\n",
      "    Loss after mini-batch   100: 0.15585\n",
      "    Loss after mini-batch   150: 0.15589\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "    Loss after mini-batch   200: 0.15825\n",
      "Starting epoch 2\n",
      "    Loss after mini-batch    50: 0.14772\n",
      "    Loss after mini-batch   100: 0.15783\n",
      "    Loss after mini-batch   150: 0.15562\n",
      "    Loss after mini-batch   200: 0.15370\n",
      "Starting epoch 3\n",
      "    Loss after mini-batch    50: 0.15013\n",
      "    Loss after mini-batch   100: 0.15044\n",
      "    Loss after mini-batch   150: 0.14894\n",
      "    Loss after mini-batch   200: 0.15829\n",
      "Starting epoch 4\n",
      "    Loss after mini-batch    50: 0.14647\n",
      "    Loss after mini-batch   100: 0.14365\n",
      "    Loss after mini-batch   150: 0.15970\n",
      "    Loss after mini-batch   200: 0.15232\n",
      "Starting epoch 5\n",
      "    Loss after mini-batch    50: 0.15028\n",
      "    Loss after mini-batch   100: 0.14706\n",
      "    Loss after mini-batch   150: 0.14865\n",
      "    Loss after mini-batch   200: 0.14988\n",
      "Starting epoch 6\n",
      "    Loss after mini-batch    50: 0.14911\n",
      "    Loss after mini-batch   100: 0.14035\n",
      "    Loss after mini-batch   150: 0.14213\n",
      "    Loss after mini-batch   200: 0.14785\n",
      "Starting epoch 7\n",
      "    Loss after mini-batch    50: 0.14468\n",
      "    Loss after mini-batch   100: 0.14567\n",
      "    Loss after mini-batch   150: 0.14202\n",
      "    Loss after mini-batch   200: 0.14324\n",
      "Starting epoch 8\n",
      "    Loss after mini-batch    50: 0.13728\n",
      "    Loss after mini-batch   100: 0.14822\n",
      "    Loss after mini-batch   150: 0.14315\n",
      "    Loss after mini-batch   200: 0.14471\n",
      "Starting epoch 9\n",
      "    Loss after mini-batch    50: 0.12977\n",
      "    Loss after mini-batch   100: 0.14382\n",
      "    Loss after mini-batch   150: 0.14104\n",
      "    Loss after mini-batch   200: 0.14321\n",
      "Starting epoch 10\n",
      "    Loss after mini-batch    50: 0.13555\n",
      "    Loss after mini-batch   100: 0.14104\n",
      "    Loss after mini-batch   150: 0.14148\n",
      "    Loss after mini-batch   200: 0.14219\n",
      "Starting testing\n",
      "----------------\n",
      "Accuracy for fold 4: 95.66 %\n",
      "F1 for fold 4: 0.96 \n",
      "Runtime for fold 4: 0.0057 s\n",
      "--------------------------------\n",
      "K-FOLD CROSS VALIDATION RESULTS FOR 5 FOLDS\n",
      "--------------------------------\n",
      "Fold 0: 91.63673678809646 %\n",
      "Fold 1: 92.86813750641355 %\n",
      "Fold 2: 94.08671113391482 %\n",
      "Fold 3: 94.6119307248236 %\n",
      "Fold 4: 95.66388710711995 %\n",
      "Average Accuracy: 93.77348065207367 %\n",
      "Average F1: 0.9379559245843282\n",
      "Average Runtime: 0.005712414296929129 s\n"
     ]
    }
   ],
   "source": [
    "trainedModel, res_acc, res_f1, res_runtime = runkfoldcv(Model, dataset, device, k_folds, batch_size, learning_rate, num_epochs, momentum, l2reg)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "39cec40d",
   "metadata": {},
   "source": [
    "## Save model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "a8ef036d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model saved as: VGGFC_PSD_1024_20\n"
     ]
    }
   ],
   "source": [
    "# Save model\n",
    "model_type = 'VGGFC'\n",
    "model_name = model_type+'_'+str(feat_name)+'_'+str(n_per_seg)+'_'+str(seg_len)\n",
    "model_path = '../saved_models/'\n",
    "trainedModel = trainedModel.cpu()\n",
    "torch.save(trainedModel, model_path+model_name)\n",
    "print('Model saved as:', model_name)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "195f509d",
   "metadata": {},
   "outputs": [],
   "source": [
    "### Test reload\n",
    "# m2 = torch.load(model_path+model_name)\n",
    "# in2 = dataset.__getitem__(0)[0]\n",
    "# out = m2(in2)\n",
    "# _,pred = torch.max(out,1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a62a2438",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
